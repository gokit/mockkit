package static


import (
	"bytes"
	"compress/gzip"
	"fmt"
	"io"
)

type fileData struct{
  path string
  root string
  data []byte
}

var (
  assets = map[string][]string{
    
      ".tml": []string{  // all .tml assets.
        
          "mock.tml",
        
      },
    
  }

  assetFiles = map[string]fileData{
    
      
        "mock.tml": { // all .tml assets.
          data: []byte("\x1f\x8b\x08\x00\x00\x00\x00\x00\x00\xff\xd4\x55\x4d\x6f\xe3\x36\x10\xbd\x1b\xf0\x7f\x98\x02\x3d\xc8\x85\x2b\xa7\xd7\x14\x3a\x04\x6d\x02\x04\x68\x83\xa2\x09\xd0\x43\x90\x03\x43\x8d\x2c\x22\x14\x29\x90\x94\x1d\x57\xd0\x7f\x5f\xf0\x43\x12\x2d\x5b\x41\xb2\x59\x2c\xb0\xba\x24\x1e\xbe\xf9\x20\xe7\xcd\x9b\xe5\xa2\x6d\x7f\xbe\x15\x06\x55\x41\x28\xde\x91\x0a\xe1\x32\x83\xf4\xd8\xd2\x75\xcb\x85\x05\x82\x22\x62\x8b\x90\xfe\x8d\xa6\x94\xb9\x76\xf6\xcd\x06\xfc\xcf\x3f\x08\xe7\x37\x52\xb5\x6d\x6a\x7d\xba\x0e\x72\x2c\x98\x40\x0d\x04\xcc\xa1\x46\xd8\x97\x8c\x96\x50\x4a\x9e\x6b\xa8\xd0\x90\x5f\x73\x34\x84\x71\x0d\xe4\x59\x36\x06\x4c\x89\xb0\x65\x3b\x26\xb6\x40\x09\xb7\x66\xad\x25\x65\xc4\x60\xee\x92\xec\x99\x29\x1d\x68\x5a\x6f\xd7\xa5\x43\xce\x64\x65\x43\x97\x32\x4f\x97\x0b\x97\x74\xa6\x34\x6d\x54\x43\x4d\xbb\x5c\x00\x00\xfc\x57\xa2\x00\xc3\x2a\x4c\x1f\x58\x85\xde\x76\x6f\x88\x32\x53\xe3\xb5\xc8\x63\x93\x37\x6e\x36\xf0\x67\xb8\x88\x2c\xa0\x26\x82\x51\x60\x05\xe8\x86\x96\x20\x29\x6d\x94\x4e\x3d\xf0\x1f\x7b\x74\x6f\x08\x7d\x81\xc7\xa7\xe7\x83\xc1\xc8\x7c\xad\x94\x54\xc0\xfa\x6b\xb5\x5d\x14\xfd\x4a\x6d\x9b\x0a\x85\x81\x1d\xe1\x0d\xf6\xd1\xc6\x66\x5c\xa9\xad\xef\x84\x37\x53\x52\x33\x43\x38\xfb\x1f\xa1\xbf\x6d\xdb\xa6\xd7\xaf\x0f\x87\x1a\x47\x14\x8a\xbc\x8b\x93\xfc\x8b\xa6\x51\x62\x2e\x85\x3f\xfd\x78\x16\x08\x69\x3a\x47\x1e\x14\x79\x60\xd2\x66\x63\xd1\x93\x2e\xde\x0b\x66\x68\x19\xb1\xa6\x68\x04\x35\x4c\x8a\x98\x3e\xac\xaa\x39\xda\xd7\xb0\x00\xdf\xc5\x81\x19\x2e\x6e\x15\xa8\x59\x48\x15\xd8\x32\xcd\x03\x44\x43\xc1\xd0\xd2\xd0\xc7\x24\x9c\xcb\xbd\x86\x83\x6c\xa0\x56\x72\xc7\x72\x1c\xd3\x10\x5b\x80\xed\xac\x0b\x6e\x4a\xd4\x38\xd4\xa5\xc1\xc8\xc1\xa3\xe0\xf8\xca\x9e\x39\x82\x41\x6d\x98\xd8\xf6\x04\x9c\xbd\xe7\x11\x05\xcf\x8f\x96\x3f\x09\xef\x3b\x32\x59\xc3\xe3\xd3\x79\x5e\x4f\x5c\x6e\x1a\x41\x5d\xb5\x49\xdb\xa6\x3d\x8d\xfe\x62\xda\x80\x51\x0d\x76\xdd\x0a\xec\x81\x6f\x6e\x6c\x8e\xdb\x07\xa1\x7f\x6f\x8c\xff\x38\x56\x51\x77\xde\x3d\xa9\x51\xa7\x4e\xd0\xcb\x85\xad\x1e\x12\x1b\x17\x7e\x39\x05\xf8\xa7\x5c\x8d\x15\xcc\x5e\xb4\x6d\x59\x01\x42\x1a\xac\x6a\x73\x80\x64\x7a\xe9\x95\x77\x3d\x7d\x8a\x30\x29\xa1\x4d\x3b\xa2\x9c\x38\xa1\x9a\x11\x96\x7e\xa2\x72\x2c\x50\xf9\xa7\x5f\x05\x5f\xfb\xb1\x02\x50\x29\x2b\xb0\x0a\xa9\xdc\xa1\x4a\x56\xbf\x3b\xcb\x4f\x19\x08\xc6\x21\x82\xda\xcf\x28\x42\x9d\x1c\x57\xe4\x05\x13\x2f\x1a\x6b\xf8\xed\xe2\xe2\x62\x75\x0e\x98\xf9\xbf\x8f\x97\xaa\x11\x4e\xa6\x9c\xd8\x24\xce\xb8\xf6\xd7\x7c\xea\x0b\xec\x3f\x7f\x9b\x34\x12\xa1\xcc\x16\x34\x0f\xf2\x02\x16\x52\x8d\xb0\x2e\x0e\x1c\xf0\x56\x2e\x33\x2f\x98\x77\x72\x9f\x44\x35\xdb\x7e\xa6\x67\x99\x9d\x01\xa9\x6b\x14\x79\x32\x0b\x59\x87\xf0\x21\x5c\x67\xe3\xfa\x7f\x43\x5a\x27\xe7\xa7\x79\xc3\xa9\x17\xf6\x2c\x06\xf7\xfe\x33\x92\x1a\x90\x67\x35\x2f\x83\x93\xd9\x8b\x64\xce\x1b\x6c\xd3\x1d\xeb\x02\xbd\x2c\x5c\x5b\x8e\xf5\x3e\xa7\x2f\x72\x33\x99\xd9\xc8\x65\x18\x4e\xe4\x1a\xe3\x08\x03\x7d\x23\xb0\xe5\xce\x57\x44\x8e\x77\xc3\xfc\x12\xf8\xfc\xdb\x28\xbf\x74\xce\x55\xfe\xce\x9d\x71\x6b\x85\x61\xdc\x18\x54\x0a\xaa\xd0\xe0\xb0\x19\xa6\x3b\xc3\xea\xcc\x64\x43\xcc\x44\x1e\x97\x71\x0a\x57\x9c\x0f\x5e\x7b\xc6\xb9\xdf\xf2\x6b\xd0\x12\x48\x9e\x83\x40\x8a\x5a\x13\x75\xf0\x3e\x82\x70\xe0\x72\xcb\xe8\xfc\x0a\x70\x65\x7f\x74\x01\xfc\x38\x6a\x7e\x8a\xb4\x17\x3e\x56\xf3\xf3\x98\xef\x27\xe5\xef\x98\xcb\xcf\xcd\xe4\xb7\x9a\xc7\x37\x87\xe4\x68\x60\xe3\x89\xf9\x12\x00\x00\xff\xff\x27\x0a\x20\x0f\xd7\x0b\x00\x00"),
          path: "mock.tml",
          root: "mock.tml",
        },
      
    
  }
)

//==============================================================================

// FilesFor returns all files that use the provided extension, returning a
// empty/nil slice if none is found.
func FilesFor(ext string) []string {
  return assets[ext]
}

// MustFindFile calls FindFile to retrieve file reader with path else panics.
func MustFindFile(path string, doGzip bool) (io.Reader, int64) {
  reader, size, err := FindFile(path, doGzip)
  if err != nil {
    panic(err)
  }

  return reader, size
}

// FindDecompressedGzippedFile returns a io.Reader by seeking the giving file path if it exists.
// It returns an uncompressed file.
func FindDecompressedGzippedFile(path string) (io.Reader, int64, error){
	return FindFile(path, true)
}

// MustFindDecompressedGzippedFile panics if error occured, uses FindUnGzippedFile underneath.
func MustFindDecompressedGzippedFile(path string) (io.Reader, int64){
	reader, size, err := FindDecompressedGzippedFile(path)
	if err != nil {
		panic(err)
	}
	return reader, size
}

// FindGzippedFile returns a io.Reader by seeking the giving file path if it exists.
// It returns an uncompressed file.
func FindGzippedFile(path string) (io.Reader, int64, error){
	return FindFile(path, false)
}

// MustFindGzippedFile panics if error occured, uses FindUnGzippedFile underneath.
func MustFindGzippedFile(path string) (io.Reader, int64){
	reader, size, err := FindGzippedFile(path)
	if err != nil {
		panic(err)
	}
	return reader, size
}

// FindFile returns a io.Reader by seeking the giving file path if it exists.
func FindFile(path string, doGzip bool) (io.Reader, int64, error){
	reader, size, err := FindFileReader(path)
	if err != nil {
		return nil, size, err
	}

	if !doGzip {
		return reader, size, nil
	}

  gzr, err := gzip.NewReader(reader)
	return gzr, size, err
}

// MustFindFileReader returns bytes.Reader for path else panics.
func MustFindFileReader(path string) (*bytes.Reader, int64){
	reader, size, err := FindFileReader(path)
	if err != nil {
		panic(err)
	}
	return reader, size
}

// FindFileReader returns a io.Reader by seeking the giving file path if it exists.
func FindFileReader(path string) (*bytes.Reader, int64, error){
  item, ok := assetFiles[path]
  if !ok {
    return nil,0, fmt.Errorf("File %q not found in file system", path)
  }

  return bytes.NewReader(item.data), int64(len(item.data)), nil
}

// MustReadFile calls ReadFile to retrieve file content with path else panics.
func MustReadFile(path string, doGzip bool) string {
  body, err := ReadFile(path, doGzip)
  if err != nil {
    panic(err)
  }

  return body
}

// ReadFile attempts to return the underline data associated with the given path
// if it exists else returns an error.
func ReadFile(path string, doGzip bool) (string, error){
  body, err := ReadFileByte(path, doGzip)
  return string(body), err
}

// MustReadFileByte calls ReadFile to retrieve file content with path else panics.
func MustReadFileByte(path string, doGzip bool) []byte {
  body, err := ReadFileByte(path, doGzip)
  if err != nil {
    panic(err)
  }

  return body
}

// ReadFileByte attempts to return the underline data associated with the given path
// if it exists else returns an error.
func ReadFileByte(path string, doGzip bool) ([]byte, error){
  reader, _, err := FindFile(path, doGzip)
  if err != nil {
    return nil, err
  }

  if closer, ok := reader.(io.Closer); ok {
    defer closer.Close()
  }

  var bu bytes.Buffer

  _, err = io.Copy(&bu, reader);
  if err != nil && err != io.EOF {
   return nil, fmt.Errorf("File %q failed to be read: %+q", path, err)
  }

  return bu.Bytes(), nil
}
